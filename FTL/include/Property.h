#pragma once

#include "PointerDataType.h"

namespace FTL
{
	// Return type specialization
	template <class Type, bool isFundamental = std::is_fundamental<Type>::value>
	class PropertyInterfaceType;

	template <class Type>
	class PropertyInterfaceType<Type, true>
	{
	public:
		typedef Type Type;
	};

	template <class Type>
	class PropertyInterfaceType<Type, false>
	{
	public:
		typedef Type& Type;
	};

	// Default getter & setter
	template <class Type, class InterfaceType>
	class AutoGeneratedGetterSetter
	{
	public:
		AutoGeneratedGetterSetter() {}
		AutoGeneratedGetterSetter(Type value) : value(value) {}

		InterfaceType get()
		{
			return static_cast<InterfaceType>(value);
		}

		void set(InterfaceType rhs)
		{
			value = rhs;
		}

	private:
		Type value;
	};

	// Base class
	template <class Type, bool IsPointer = IsPointer<Type>::value>
	class PropertyBase;

	// Base class non-pointer specialization
	template <class Type>
	class PropertyBase<Type, false>
	{
	public:
		static const bool isPointer = false;

		typedef Type Type;
		typedef typename PropertyInterfaceType<Type>::Type InterfaceType;

		typedef std::function<InterfaceType(void)> GetterType;
		typedef std::function<void(InterfaceType)> SetterType;

	protected:
		PropertyBase() = delete;

		PropertyBase(GetterType getter, SetterType setter) : getter(getter), setter(setter)
		{

		}

		InterfaceType get()
		{
			return getter();
		}

		InterfaceType get() const
		{
			return getter();
		}

		InterfaceType operator=(InterfaceType rhs)
		{
			setter(rhs);
			return rhs;
		}

		operator InterfaceType()
		{
			return get();
		}

		typename std::remove_reference<InterfaceType>::type* operator->()
		{
			return &getter();
		}

		InterfaceType operator+(const PropertyBase& rhs)
		{
			return get() + rhs.get();
		}

		InterfaceType operator+(InterfaceType rhs)
		{
			return get() + rhs;
		}

		InterfaceType operator-(const PropertyBase& rhs)
		{
			return get() - rhs.get();
		}

		InterfaceType operator-(InterfaceType rhs)
		{
			return get() - rhs;
		}

		InterfaceType operator*(const PropertyBase& rhs)
		{
			return get() * rhs.get();
		}

		InterfaceType operator*(InterfaceType rhs)
		{
			return get() * rhs;
		}

		InterfaceType operator/(const PropertyBase& rhs)
		{
			return get() / rhs.get();
		}

		InterfaceType operator/(InterfaceType rhs)
		{
			return get() / rhs;
		}

		PropertyBase operator+=(const PropertyBase& rhs)
		{
			setter(get() + rhs.get());

			return *this;
		}

		PropertyBase operator+=(InterfaceType rhs)
		{
			setter(get() + rhs);

			return *this;
		}

		PropertyBase operator-=(const PropertyBase& rhs)
		{
			setter(get() - rhs.get());

			return *this;
		}

		PropertyBase operator-=(InterfaceType rhs)
		{
			setter(get() - rhs);

			return *this;
		}

		PropertyBase operator*=(const PropertyBase& rhs)
		{
			setter(get() * rhs.get());

			return *this;
		}

		PropertyBase operator*=(InterfaceType rhs)
		{
			setter(get() * rhs);

			return *this;
		}

		PropertyBase operator/=(const PropertyBase& rhs)
		{
			setter(get() / rhs.get());

			return *this;
		}

		PropertyBase operator/=(InterfaceType rhs)
		{
			setter(get() / rhs);

			return *this;
		}

	private:
		GetterType getter;
		SetterType setter;
	};

	// Base class pointer specialization
	template <class Type>
	class PropertyBase<Type, true>
	{
	public:
		static const bool isPointer = true;

		typedef Type Type;
		typedef Type InterfaceType;

		typedef std::function<InterfaceType()> GetterType;
		typedef std::function<void(InterfaceType)> SetterType;

	protected:
		PropertyBase() = delete;

		PropertyBase(GetterType getter, SetterType setter) : getter(getter), setter(setter)
		{

		}

		InterfaceType get()
		{
			return getter(value);
		}

		InterfaceType get() const
		{
			return getter(value);
		}

		InterfaceType operator=(InterfaceType rhs)
		{
			setter(rhs);
			return rhs;
		}

		operator InterfaceType()
		{
			return get();
		}

		decltype(*Type()) operator*()
		{
			return *getter();
		}

		InterfaceType operator->()
		{
			return getter();
		}

		const decltype(*Type()) operator*() const
		{
			return *getter();
		}

		const InterfaceType operator->() const
		{
			return getter();
		}

	private:
		GetterType getter;
		SetterType setter;
	};

	// Constructor
	template <class Type, bool isAutoGenerated>
	class PropertyConstructor;

	// Auto generated
	template <class Type>
	class PropertyConstructor<Type, true> : public PropertyBase<Type>
	{
	public:
		typedef typename PropertyBase<Type>::InterfaceType InterfaceType;
		using GetterType = typename PropertyBase<Type>::GetterType;
		using SetterType = typename PropertyBase<Type>::SetterType;

	private:
		using AutoGen = AutoGeneratedGetterSetter<Type, InterfaceType>;

	public:
		PropertyConstructor() : PropertyConstructor(AutoGen()) {}

		explicit PropertyConstructor(InterfaceType value) : PropertyConstructor(AutoGen(value)) {}

	private:
		PropertyConstructor(AutoGen autoGen)
			: PropertyConstructor
			(
				autoGen,
				std::bind(&AutoGen::get, &this->autoGen),
				std::bind(&AutoGen::set, &this->autoGen, std::placeholders::_1)
			)
		{}

		PropertyConstructor(AutoGen autoGen, GetterType getter, SetterType setter)
			: autoGen(autoGen), PropertyBase(getter, setter) {}

		AutoGen autoGen;
	};

	// Manual
	template <class Type>
	class PropertyConstructor<Type, false> : public PropertyBase<Type>
	{
	public:
		typedef typename PropertyBase<Type>::InterfaceType InterfaceType;
		using GetterType = typename PropertyBase<Type>::GetterType;
		using SetterType = typename PropertyBase<Type>::SetterType;

		PropertyConstructor(GetterType getter, SetterType setter) : PropertyBase(getter, setter) {}
	};

	// Declare
	template <class OwnerClass, class Type, bool isGetterPrivate, bool isSetterPrivate, bool isAutoGenerated, bool isPointer = IsPointer<Type>::value>
	class Property;

	// Non-pointer specialization : Both public
	template <class OwnerClass, class Type, bool isAutoGenerated>
	class Property<OwnerClass, Type, false, false, isAutoGenerated, false> : public PropertyConstructor<Type, isAutoGenerated>
	{
	public:
		friend OwnerClass;

		using PropertyConstructor::PropertyConstructor;

		typedef typename PropertyBase<Type>::InterfaceType InterfaceType;

		decltype(auto) get()
		{
			return PropertyBase::get();
		}

		decltype(auto) get() const
		{
			return PropertyBase::get();
		}

		decltype(auto) operator=(InterfaceType rhs)
		{
			return PropertyBase::operator=(rhs);
		}

		operator InterfaceType()
		{
			return PropertyBase::operator InterfaceType();
		}

		decltype(auto) operator->()
		{
			return PropertyBase::operator->();
		}
	};

	// Non-pointer specialization : Setter private, getter public
	template <class OwnerClass, class Type, bool isAutoGenerated>
	class Property<OwnerClass, Type, false, true, isAutoGenerated, false> : public PropertyConstructor<Type, isAutoGenerated>
	{
	public:
		friend OwnerClass;

		using PropertyConstructor::PropertyConstructor;

		typedef typename PropertyBase<Type>::InterfaceType InterfaceType;

		decltype(auto) get()
		{
			return PropertyBase::get();
		}

		decltype(auto) get() const
		{
			return PropertyBase::get();
		}

	private:
		decltype(auto) operator=(InterfaceType rhs)
		{
			return PropertyBase::operator=(rhs);
		}

	public:
		operator InterfaceType()
		{
			return PropertyBase::operator InterfaceType();
		}

		decltype(auto) operator->()
		{
			return PropertyBase::operator->();
		}
	};

	// Non-pointer specialization : Setter public, Getter private
	template <class OwnerClass, class Type, bool isAutoGenerated>
	class Property<OwnerClass, Type, true, false, isAutoGenerated, false> : public PropertyConstructor<Type, isAutoGenerated>
	{
	public:
		friend OwnerClass;

		using PropertyConstructor::PropertyConstructor;

		typedef typename PropertyBase<Type>::InterfaceType InterfaceType;

		decltype(auto) operator=(InterfaceType rhs)
		{
			return PropertyBase::operator=(rhs);
		}

	private:
		decltype(auto) get()
		{
			return PropertyBase::get();
		}

		decltype(auto) get() const
		{
			return PropertyBase::get();
		}

		operator InterfaceType()
		{
			return PropertyBase::operator InterfaceType();
		}

		decltype(auto) operator->()
		{
			return PropertyBase::operator->();
		}
	};

	// Non-pointer specialization : Both private
	template <class OwnerClass, class Type, bool isAutoGenerated>
	class Property<OwnerClass, Type, true, true, isAutoGenerated, false> : public PropertyConstructor<Type, isAutoGenerated>
	{
	public:
		friend OwnerClass;

		using PropertyConstructor::PropertyConstructor;

		typedef typename PropertyBase<Type>::InterfaceType InterfaceType;

	private:
		decltype(auto) get()
		{
			return PropertyBase::get();
		}

		decltype(auto) get() const
		{
			return PropertyBase::get();
		}

		decltype(auto) operator=(InterfaceType rhs)
		{
			return PropertyBase::operator=(rhs);
		}

		operator InterfaceType()
		{
			return PropertyBase::operator InterfaceType();
		}

		decltype(auto) operator->()
		{
			return PropertyBase::operator->();
		}
	};

	// Pointer specialization : Both public
	template <class OwnerClass, class Type, bool isAutoGenerated>
	class Property<OwnerClass, Type, false, false, isAutoGenerated, true> : public PropertyConstructor<Type, isAutoGenerated>
	{
	public:
		friend OwnerClass;

		using PropertyConstructor::PropertyConstructor;

		typedef typename PropertyBase<Type>::InterfaceType InterfaceType;

		decltype(auto) get()
		{
			return PropertyBase::get();
		}

		decltype(auto) get() const
		{
			return PropertyBase::get();
		}

		decltype(auto) operator=(InterfaceType rhs)
		{
			return PropertyBase::operator=(rhs);
		}

		operator InterfaceType()
		{
			return PropertyBase::operator InterfaceType();
		}

		decltype(auto) operator*()
		{
			return PropertyBase::operator*();
		}

		decltype(auto) operator->()
		{
			return PropertyBase::operator->();
		}

		decltype(auto) operator*() const
		{
			return PropertyBase::operator*();
		}

		decltype(auto) operator->() const
		{
			return PropertyBase::operator->();
		}
	};

	// Pointer specialization : Setter private, getter public
	template <class OwnerClass, class Type, bool isAutoGenerated>
	class Property<OwnerClass, Type, false, true, isAutoGenerated, true> : public PropertyConstructor<Type, isAutoGenerated>
	{
	public:
		friend OwnerClass;

		using PropertyConstructor::PropertyConstructor;

		typedef typename PropertyBase<Type>::InterfaceType InterfaceType;

		decltype(auto) get()
		{
			return PropertyBase::get();
		}

		decltype(auto) get() const
		{
			return PropertyBase::get();
		}

	private:
		decltype(auto) operator=(InterfaceType rhs)
		{
			return PropertyBase::operator=(rhs);
		}

	public:
		operator InterfaceType()
		{
			return PropertyBase::operator InterfaceType();
		}

		decltype(auto) operator*()
		{
			return PropertyBase::operator*();
		}

		decltype(auto) operator->()
		{
			return PropertyBase::operator->();
		}

		decltype(auto) operator*() const
		{
			return PropertyBase::operator*();
		}

		decltype(auto) operator->() const
		{
			return PropertyBase::operator->();
		}
	};

	// Pointer specialization : Setter public, getter private
	template <class OwnerClass, class Type, bool isAutoGenerated>
	class Property<OwnerClass, Type, true, false, isAutoGenerated, true> : public PropertyConstructor<Type, isAutoGenerated>
	{
	public:
		friend OwnerClass;

		using PropertyConstructor::PropertyConstructor;

		typedef typename PropertyBase<Type>::InterfaceType InterfaceType;

		decltype(auto) operator=(InterfaceType rhs)
		{
			return PropertyBase::operator=(rhs);
		}

	private:
		decltype(auto) get()
		{
			return PropertyBase::get();
		}

		decltype(auto) get() const
		{
			return PropertyBase::get();
		}

		operator InterfaceType()
		{
			return PropertyBase::operator InterfaceType();
		}

		decltype(auto) operator*()
		{
			return PropertyBase::operator*();
		}

		decltype(auto) operator->()
		{
			return PropertyBase::operator->();
		}

		decltype(auto) operator*() const
		{
			return PropertyBase::operator*();
		}

		decltype(auto) operator->() const
		{
			return PropertyBase::operator->();
		}
	};

	// Pointer specialization : Both private
	template <class OwnerClass, class Type, bool isAutoGenerated>
	class Property<OwnerClass, Type, true, true, isAutoGenerated, true> : public PropertyConstructor<Type, isAutoGenerated>
	{
	public:
		friend OwnerClass;

		using PropertyConstructor::PropertyConstructor;

		typedef typename PropertyBase<Type>::InterfaceType InterfaceType;

	private:
		decltype(auto) get()
		{
			return PropertyBase::get();
		}

		decltype(auto) get() const
		{
			return PropertyBase::get();
		}

		decltype(auto) operator=(InterfaceType rhs)
		{
			return PropertyBase::operator=(rhs);
		}

		operator InterfaceType()
		{
			return PropertyBase::operator InterfaceType();
		}

		decltype(auto) operator*()
		{
			return PropertyBase::operator*();
		}

		decltype(auto) operator->()
		{
			return PropertyBase::operator->();
		}

		decltype(auto) operator*() const
		{
			return PropertyBase::operator*();
		}

		decltype(auto) operator->() const
		{
			return PropertyBase::operator->();
		}
	};
}