#pragma once

#include "PointerDataType.h"

namespace FTL
{
	// Property type
	enum class PropertyType
	{
		Manual,
		AutoGen,
		GetterOnly,
		SetterOnly,
	};

	enum class PropertyAccessorSaveType
	{
		GetterOnly,
		SetterOnly,
		Both
	};

	// Return type specialization
	template <class Type, bool isReference = std::is_fundamental<Type>::value == false && IsPointer<Type>::value == false>
	class PropertyInterfaceType;

	template <class Type>
	class PropertyInterfaceType<Type, false>
	{
	public:
		typedef Type Type;
	};

	template <class Type>
	class PropertyInterfaceType<Type, true>
	{
	public:
		typedef Type& Type;
	};

	// Default getter & setter
	template <class Type, class InterfaceType>
	class AutoGeneratedGetterSetter
	{
	public:
		AutoGeneratedGetterSetter() {}
		AutoGeneratedGetterSetter(Type value) : value(value) {}

		InterfaceType get()
		{
			return static_cast<InterfaceType>(value);
		}

		void set(InterfaceType rhs)
		{
			value = rhs;
		}

	private:
		Type value;
	};

	// Getter base class
	template <class Type, bool isPointer = IsPointer<Type>::value>
	class PropertyGetterBase;

	// Non pointer getter
	template <class Type>
	class PropertyGetterBase<Type, false>
	{
	public:
		using InterfaceType = typename PropertyInterfaceType<Type>::Type;

		using GetterType = std::function<InterfaceType(void)>;

	protected:
		PropertyGetterBase(GetterType getter) : getter(getter) {}

		InterfaceType get()
		{
			return getter();
		}

		InterfaceType get() const
		{
			return getter();
		}

		operator InterfaceType()
		{
			return get();
		}

		typename std::remove_reference<InterfaceType>::type* operator->()
		{
			return &getter();
		}

		InterfaceType operator+(const PropertyGetterBase& rhs)
		{
			return get() + rhs.get();
		}

		InterfaceType operator+(InterfaceType rhs)
		{
			return get() + rhs;
		}

		InterfaceType operator-(const PropertyGetterBase& rhs)
		{
			return get() - rhs.get();
		}

		InterfaceType operator-(InterfaceType rhs)
		{
			return get() - rhs;
		}

		InterfaceType operator*(const PropertyGetterBase& rhs)
		{
			return get() * rhs.get();
		}

		InterfaceType operator*(InterfaceType rhs)
		{
			return get() * rhs;
		}

		InterfaceType operator/(const PropertyGetterBase& rhs)
		{
			return get() / rhs.get();
		}

		InterfaceType operator/(InterfaceType rhs)
		{
			return get() / rhs;
		}

	protected:
		GetterType getter;
	};

	// Pointer getter
	template <class Type>
	class PropertyGetterBase<Type, true>
	{
	public:
		using InterfaceType = typename PropertyInterfaceType<Type>::Type;

		using GetterType = std::function<InterfaceType(void)>;

	protected:
		PropertyGetterBase(GetterType getter) : getter(getter) {}

		InterfaceType get()
		{
			return getter();
		}

		InterfaceType get() const
		{
			return getter();
		}

		operator InterfaceType()
		{
			return get();
		}

		decltype(*Type()) operator*()
		{
			return *getter();
		}

		InterfaceType operator->()
		{
			return getter();
		}

		const decltype(*Type()) operator*() const
		{
			return *getter();
		}

		const InterfaceType operator->() const
		{
			return getter();
		}

	protected:
		GetterType getter;
	};

	// Setter base class
	template <class Type>
	class PropertySetterBase
	{
	public:
		using InterfaceType = typename PropertyInterfaceType<Type>::Type;

		using SetterType = std::function<void(InterfaceType)>;

	protected:
		PropertySetterBase(SetterType setter) : setter(setter) {}

		InterfaceType operator=(InterfaceType rhs)
		{
			setter(rhs);
			return rhs;
		}

	protected:
		SetterType setter;
	};

	// Base class
	template <class Type, PropertyAccessorSaveType AccSaveType>
	class PropertyBase;

	// Base class getter only specialization
	template <class Type>
	class PropertyBase<Type, PropertyAccessorSaveType::GetterOnly> : public PropertyGetterBase<Type>
	{
	public:
		static const bool isPointer = IsPointer<Type>::value;

		using InterfaceType = typename PropertyInterfaceType<Type>::Type;

		using GetterType = typename PropertyGetterBase<Type>::GetterType;
		using SetterType = typename PropertySetterBase<Type>::SetterType;

	protected:
		PropertyBase() = delete;
		PropertyBase(const PropertyBase& rhs) = delete;

		PropertyBase(GetterType getter) : PropertyGetterBase(getter) {}

		InterfaceType operator+(const PropertyBase& rhs)
		{
			return get() + rhs.get();
		}

		InterfaceType operator+(InterfaceType rhs)
		{
			return get() + rhs;
		}

		InterfaceType operator-(const PropertyBase& rhs)
		{
			return get() - rhs.get();
		}

		InterfaceType operator-(InterfaceType rhs)
		{
			return get() - rhs;
		}

		InterfaceType operator*(const PropertyBase& rhs)
		{
			return get() * rhs.get();
		}

		InterfaceType operator*(InterfaceType rhs)
		{
			return get() * rhs;
		}

		InterfaceType operator/(const PropertyBase& rhs)
		{
			return get() / rhs.get();
		}

		InterfaceType operator/(InterfaceType rhs)
		{
			return get() / rhs;
		}

		InterfaceType operator+=(const PropertyBase& rhs)
		{
			InterfaceType ret = get() + rhs.get();
			setter(ret);

			return ret;
		}

		InterfaceType operator+=(InterfaceType rhs)
		{
			InterfaceType ret = get() + rhs;
			setter(ret);

			return ret;
		}

		InterfaceType operator-=(const PropertyBase& rhs)
		{
			InterfaceType ret = get() - rhs.get();
			setter(ret);

			return ret;

		}

		InterfaceType operator-=(InterfaceType rhs)
		{
			InterfaceType ret = get() - rhs;
			setter(ret);

			return ret;
		}

		InterfaceType operator*=(const PropertyBase& rhs)
		{
			InterfaceType ret = get() * rhs.get();
			setter(ret);

			return ret;
		}

		InterfaceType operator*=(InterfaceType rhs)
		{
			InterfaceType ret = get() * rhs;
			setter(ret);

			return ret;
		}

		InterfaceType operator/=(const PropertyBase& rhs)
		{
			InterfaceType ret = get() / rhs.get();
			setter(ret);

			return ret;
		}

		InterfaceType operator/=(InterfaceType rhs)
		{
			InterfaceType ret = get() / rhs;
			setter(ret);

			return ret;
		}
	};

	// Base class setter only specialization
	template <class Type>
	class PropertyBase<Type, PropertyAccessorSaveType::SetterOnly> : public PropertySetterBase<Type>
	{
	public:
		static const bool isPointer = IsPointer<Type>::value;

		using InterfaceType = typename PropertyInterfaceType<Type>::Type;

		using GetterType = typename PropertyGetterBase<Type>::GetterType;
		using SetterType = typename PropertySetterBase<Type>::SetterType;

	protected:
		PropertyBase() = delete;
		PropertyBase(const PropertyBase& rhs) = delete;

		PropertyBase(SetterType setter) : PropertySetterBase(setter) {}
	};

	// Base class both specialization
	template <class Type>
	class PropertyBase<Type, PropertyAccessorSaveType::Both> : public PropertyGetterBase<Type>, public PropertySetterBase<Type>
	{
	public:
		static const bool isPointer = IsPointer<Type>::value;

		using InterfaceType = typename PropertyInterfaceType<Type>::Type;

		using GetterType = typename PropertyGetterBase<Type>::GetterType;
		using SetterType = typename PropertySetterBase<Type>::SetterType;

	protected:
		PropertyBase() = delete;
		PropertyBase(const PropertyBase& rhs) = delete;

		PropertyBase(GetterType getter, SetterType setter) : PropertyGetterBase(getter), PropertySetterBase(setter) {}

		InterfaceType operator+(const PropertyBase& rhs)
		{
			return get() + rhs.get();
		}

		InterfaceType operator+(InterfaceType rhs)
		{
			return get() + rhs;
		}

		InterfaceType operator-(const PropertyBase& rhs)
		{
			return get() - rhs.get();
		}

		InterfaceType operator-(InterfaceType rhs)
		{
			return get() - rhs;
		}

		InterfaceType operator*(const PropertyBase& rhs)
		{
			return get() * rhs.get();
		}

		InterfaceType operator*(InterfaceType rhs)
		{
			return get() * rhs;
		}

		InterfaceType operator/(const PropertyBase& rhs)
		{
			return get() / rhs.get();
		}

		InterfaceType operator/(InterfaceType rhs)
		{
			return get() / rhs;
		}

		InterfaceType operator+=(const PropertyBase& rhs)
		{
			InterfaceType ret = get() + rhs.get();
			setter(ret);

			return ret;
		}

		InterfaceType operator+=(InterfaceType rhs)
		{
			InterfaceType ret = get() + rhs;
			setter(ret);

			return ret;
		}

		InterfaceType operator-=(const PropertyBase& rhs)
		{
			InterfaceType ret = get() - rhs.get();
			setter(ret);

			return ret;

		}

		InterfaceType operator-=(InterfaceType rhs)
		{
			InterfaceType ret = get() - rhs;
			setter(ret);

			return ret;
		}

		InterfaceType operator*=(const PropertyBase& rhs)
		{
			InterfaceType ret = get() * rhs.get();
			setter(ret);

			return ret;
		}

		InterfaceType operator*=(InterfaceType rhs)
		{
			InterfaceType ret = get() * rhs;
			setter(ret);

			return ret;
		}

		InterfaceType operator/=(const PropertyBase& rhs)
		{
			InterfaceType ret = get() / rhs.get();
			setter(ret);

			return ret;
		}

		InterfaceType operator/=(InterfaceType rhs)
		{
			InterfaceType ret = get() / rhs;
			setter(ret);

			return ret;
		}
	};

	// Constructor
	template <class Type, PropertyType PropType>
	class PropertyConstructor;

	// Auto generated
	template <class Type>
	class PropertyConstructor<Type, PropertyType::AutoGen> : public PropertyBase<Type, PropertyAccessorSaveType::Both>
	{
	public:
		using InterfaceType = typename PropertyInterfaceType<Type>::Type;

		using GetterType = typename PropertyBase::GetterType;
		using SetterType = typename PropertyBase::SetterType;

	private:
		using AutoGen = AutoGeneratedGetterSetter<Type, InterfaceType>;

	public:
		PropertyConstructor()
			: PropertyBase
			(
				std::bind(&AutoGen::get, &this->autoGen),
				std::bind(&AutoGen::set, &this->autoGen, std::placeholders::_1)
			) {}

		explicit PropertyConstructor(InterfaceType value) : autoGen(value),
			PropertyBase
			(
				std::bind(&AutoGen::get, &this->autoGen),
				std::bind(&AutoGen::set, &this->autoGen, std::placeholders::_1)
			) {}

	private:
		AutoGen autoGen;
	};

	// Manual
	template <class Type>
	class PropertyConstructor<Type, PropertyType::Manual> : public PropertyBase<Type, PropertyAccessorSaveType::Both>
	{
	public:
		using InterfaceType = typename PropertyBase::InterfaceType;
		using GetterType = typename PropertyBase::GetterType;
		using SetterType = typename PropertyBase::SetterType;

		PropertyConstructor(GetterType getter, SetterType setter) : PropertyBase(getter, setter) {}
	};

	// Getter only
	template <class Type>
	class PropertyConstructor<Type, PropertyType::GetterOnly> : public PropertyBase<Type, PropertyAccessorSaveType::GetterOnly>
	{
	public:
		using InterfaceType = typename PropertyBase::InterfaceType;
		using GetterType = typename PropertyBase::GetterType;
		using SetterType = typename PropertyBase::SetterType;

		PropertyConstructor(GetterType getter) : PropertyBase(getter) {}
	};

	// Setter only
	template <class Type>
	class PropertyConstructor<Type, PropertyType::SetterOnly> : public PropertyBase<Type, PropertyAccessorSaveType::SetterOnly>
	{
	public:
		using InterfaceType = typename PropertyBase::InterfaceType;
		using GetterType = typename PropertyBase::GetterType;
		using SetterType = typename PropertyBase::SetterType;

		PropertyConstructor(SetterType setter) : PropertyBase(setter) {}
	};

	// Declare
	template <class OwnerClass, class Type, bool isGetterPrivate, bool isSetterPrivate, PropertyType PropType, bool isPointer = IsPointer<Type>::value>
	class Property;

	// Non-pointer specialization : Both public
	template <class OwnerClass, class Type, PropertyType PropType>
	class Property<OwnerClass, Type, false, false, PropType, false> : public PropertyConstructor<Type, PropType>
	{
	public:
		friend OwnerClass;

		using PropertyConstructor::PropertyConstructor;

		using InterfaceType = typename PropertyConstructor<Type, PropType>::InterfaceType;

		decltype(auto) get()
		{
			return PropertyGetterBase::get();
		}

		decltype(auto) get() const
		{
			return PropertyGetterBase::get();
		}

		decltype(auto) operator=(InterfaceType rhs)
		{
			return PropertySetterBase::operator=(rhs);
		}

		operator InterfaceType()
		{
			return PropertyGetterBase::operator InterfaceType();
		}

		decltype(auto) operator->()
		{
			return PropertyGetterBase::operator->();
		}
	};

	// Non-pointer specialization : Setter private, getter public
	template <class OwnerClass, class Type, PropertyType PropType>
	class Property<OwnerClass, Type, false, true, PropType, false> : public PropertyConstructor<Type, PropType>
	{
	public:
		friend OwnerClass;

		using PropertyConstructor::PropertyConstructor;

		using InterfaceType = typename PropertyConstructor<Type, PropType>::InterfaceType;

		decltype(auto) get()
		{
			return PropertyGetterBase::get();
		}

		decltype(auto) get() const
		{
			return PropertyGetterBase::get();
		}

	private:
		decltype(auto) operator=(InterfaceType rhs)
		{
			return PropertySetterBase::operator=(rhs);
		}

	public:
		operator InterfaceType()
		{
			return PropertyGetterBase::operator InterfaceType();
		}

		decltype(auto) operator->()
		{
			return PropertyGetterBase::operator->();
		}
	};

	// Non-pointer specialization : Setter public, Getter private
	template <class OwnerClass, class Type, PropertyType PropType>
	class Property<OwnerClass, Type, true, false, PropType, false> : public PropertyConstructor<Type, PropType>
	{
	public:
		friend OwnerClass;

		using PropertyConstructor::PropertyConstructor;

		using InterfaceType = typename PropertyConstructor<Type, PropType>::InterfaceType;

		decltype(auto) operator=(InterfaceType rhs)
		{
			return PropertySetterBase::operator=(rhs);
		}

	private:
		decltype(auto) get()
		{
			return PropertyGetterBase::get();
		}

		decltype(auto) get() const
		{
			return PropertyGetterBase::get();
		}

		operator InterfaceType()
		{
			return PropertyGetterBase::operator InterfaceType();
		}

		decltype(auto) operator->()
		{
			return PropertyGetterBase::operator->();
		}
	};

	// Non-pointer specialization : Both private
	template <class OwnerClass, class Type, PropertyType PropType>
	class Property<OwnerClass, Type, true, true, PropType, false> : public PropertyConstructor<Type, PropType>
	{
	public:
		friend OwnerClass;

		using PropertyConstructor::PropertyConstructor;

		using InterfaceType = typename PropertyConstructor<Type, PropType>::InterfaceType;

	private:
		decltype(auto) get()
		{
			return PropertyGetterBase::get();
		}

		decltype(auto) get() const
		{
			return PropertyGetterBase::get();
		}

		decltype(auto) operator=(InterfaceType rhs)
		{
			return PropertySetterBase::operator=(rhs);
		}

		operator InterfaceType()
		{
			return PropertyGetterBase::operator InterfaceType();
		}

		decltype(auto) operator->()
		{
			return PropertyGetterBase::operator->();
		}
	};

	// Pointer specialization : Both public
	template <class OwnerClass, class Type, PropertyType PropType>
	class Property<OwnerClass, Type, false, false, PropType, true> : public PropertyConstructor<Type, PropType>
	{
	public:
		friend OwnerClass;

		using PropertyConstructor::PropertyConstructor;

		using InterfaceType = typename PropertyConstructor<Type, PropType>::InterfaceType;

		decltype(auto) get()
		{
			return PropertyGetterBase::get();
		}

		decltype(auto) get() const
		{
			return PropertyGetterBase::get();
		}

		decltype(auto) operator=(InterfaceType rhs)
		{
			return PropertySetterBase::operator=(rhs);
		}

		operator InterfaceType()
		{
			return PropertyGetterBase::operator InterfaceType();
		}

		decltype(auto) operator*()
		{
			return PropertyGetterBase::operator*();
		}

		decltype(auto) operator->()
		{
			return PropertyGetterBase::operator->();
		}

		decltype(auto) operator*() const
		{
			return PropertyGetterBase::operator*();
		}

		decltype(auto) operator->() const
		{
			return PropertyGetterBase::operator->();
		}
	};

	// Pointer specialization : Setter private, getter public
	template <class OwnerClass, class Type, PropertyType PropType>
	class Property<OwnerClass, Type, false, true, PropType, true> : public PropertyConstructor<Type, PropType>
	{
	public:
		friend OwnerClass;

		using PropertyConstructor::PropertyConstructor;

		using InterfaceType = typename PropertyConstructor<Type, PropType>::InterfaceType;

		decltype(auto) get()
		{
			return PropertyGetterBase::get();
		}

		decltype(auto) get() const
		{
			return PropertyGetterBase::get();
		}

	private:
		decltype(auto) operator=(InterfaceType rhs)
		{
			return PropertySetterBase::operator=(rhs);
		}

	public:
		operator InterfaceType()
		{
			return PropertyGetterBase::operator InterfaceType();
		}

		decltype(auto) operator*()
		{
			return PropertyGetterBase::operator*();
		}

		decltype(auto) operator->()
		{
			return PropertyGetterBase::operator->();
		}

		decltype(auto) operator*() const
		{
			return PropertyGetterBase::operator*();
		}

		decltype(auto) operator->() const
		{
			return PropertyGetterBase::operator->();
		}
	};

	// Pointer specialization : Setter public, getter private
	template <class OwnerClass, class Type, PropertyType PropType>
	class Property<OwnerClass, Type, true, false, PropType, true> : public PropertyConstructor<Type, PropType>
	{
	public:
		friend OwnerClass;

		using PropertyConstructor::PropertyConstructor;

		using InterfaceType = typename PropertyConstructor<Type, PropType>::InterfaceType;

		decltype(auto) operator=(InterfaceType rhs)
		{
			return PropertySetterBase::operator=(rhs);
		}

	private:
		decltype(auto) get()
		{
			return PropertyGetterBase::get();
		}

		decltype(auto) get() const
		{
			return PropertyGetterBase::get();
		}

		operator InterfaceType()
		{
			return PropertyGetterBase::operator InterfaceType();
		}

		decltype(auto) operator*()
		{
			return PropertyGetterBase::operator*();
		}

		decltype(auto) operator->()
		{
			return PropertyGetterBase::operator->();
		}

		decltype(auto) operator*() const
		{
			return PropertyGetterBase::operator*();
		}

		decltype(auto) operator->() const
		{
			return PropertyGetterBase::operator->();
		}
	};

	// Pointer specialization : Both private
	template <class OwnerClass, class Type, PropertyType PropType>
	class Property<OwnerClass, Type, true, true, PropType, true> : public PropertyConstructor<Type, PropType>
	{
	public:
		friend OwnerClass;

		using PropertyConstructor::PropertyConstructor;

		using InterfaceType = typename PropertyConstructor<Type, PropType>::InterfaceType;

	private:
		decltype(auto) get()
		{
			return PropertyGetterBase::get();
		}

		decltype(auto) get() const
		{
			return PropertyGetterBase::get();
		}

		decltype(auto) operator=(InterfaceType rhs)
		{
			return PropertySetterBase::operator=(rhs);
		}

		operator InterfaceType()
		{
			return PropertyGetterBase::operator InterfaceType();
		}

		decltype(auto) operator*()
		{
			return PropertyGetterBase::operator*();
		}

		decltype(auto) operator->()
		{
			return PropertyGetterBase::operator->();
		}

		decltype(auto) operator*() const
		{
			return PropertyGetterBase::operator*();
		}

		decltype(auto) operator->() const
		{
			return PropertyGetterBase::operator->();
		}
	};
}